---
title: "Linux 下的文件锁"
categories: [ "编程开发" ]
tags: [ "linux" ]
draft: false
slug: "620"
date: "2022-01-13 14:30:39"
---

> 本文内容为 Linux 系统通用，各个语言实现可能稍有不同，但原理相同。
> 

当多个进程或多个程序都想要修同一个文件的时候，如果不加控制，多进程或多程序将可能导致文件更新的丢失。

> 例如进程1和进程2都要写入数据到a.txt中，进程1获取到了文件句柄，进程2也获取到了文件句柄，然后进程1写入一段数据，进程2写入一段数据，进程1关闭文件句柄，会将数据flush到文件中，进程2也关闭文件句柄，也将flush到文件中，于是进程1的数据被进程2保存的数据覆盖了。
> 

所以，多进程修改同一文件的时候，需要协调每个进程：

- 保证文件在**同一时间只能被一个进程修改**，只有进程1修改完成之后，进程2才能获得修改权
- 进程1获得了修改权，就不允许进程2去读取这个文件的数据，因为进程2可能读取出来的数据是进程1修改前的**过期数据**

这种协调方式可以通过文件锁来实现。

## 文件锁分类

文件锁分两种，

- **独占锁(写锁)**
- **共享锁(读锁)**。

当进程想要修改文件的时候，申请独占锁(写锁)，当进程想要读取文件数据的时候，申请共享锁(读锁)。

独占锁和独占锁、独占锁和共享锁都是互斥的。

> 只要进程1持有了独占锁，进程2想要申请独占锁或共享锁都将失败(阻塞)，也就保证了**这一时刻只有进程1能修改文件**，只有当进程1释放了独占锁，进程2才能继续申请到独占锁或共享锁。
> 

但是共享锁和共享锁是可以共存的，这代表的是两个进程都只是要去读取数据，并不互相冲突。

## **文件锁：flock 和 lockf**

Linux上的文件锁类型主要有两种：flock和lockf。后者是fcntl系统调用的一个封装。它们之间有些区别：

- flock来自BSD，而fcntl或lockf来自POSIX，所以lockf或fcntl实现的锁也称为POSIX锁
- flock只能对整个文件加锁，而fcntl或lockf可以对文件中的部分加锁，即粒度更细的记录锁
- flock的锁是劝告锁，lockf或fcntl可以实现强制锁。所谓劝告锁，是指只有多进程双方都遵纪守法地使用flock锁才有意义，某进程使用flock，但另一进程不使用flock，则flock锁对另一进程完全无限制
- **flock锁是附加在(关联在)文件描述符上的**(见下文更深入的描述)，而lockf是关联在文件实体上的。本文后面将详细分析flock锁在文件描述符上的现象

## 参考文献

- [Perl IO：文件锁](https://www.cnblogs.com/f-ck-need-u/p/10447881.html) By [骏马金龙](https://www.cnblogs.com/f-ck-need-u/)